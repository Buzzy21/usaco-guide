---
id: ac-subsetSumQueries
source: AC
title: Subset Sum Queries
author: Rameez Parwez
---

[Official Analysis (C++)](https://atcoder.jp/contests/abc321/editorial/7281)

## Explanation

Let $\texttt{dp[a]}$ be the number of ways to achieve the sum $a$ using the current set of balls. We will update our array dynamically as balls are added or removed.

- add a ball with value $x$: To add new ways to reach sum $j$ by including the new ball we will traverse from $K$ down to $x$ while updating $\texttt{dp[j] += dp[j - x]}$

- remove a ball with value $x$: To remove the contribution of ball $x$ we will traverse from $x$ up to $K$ while updating $\texttt{dp[j] -= dp[j - x]}$

For every query we will return $dp[k]$ which contains the number of valid subsets that sum to $K$.

## Implementation

**Time Complexity:** $\mathcal{O}(QK)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <vector>

const int MOD = 998244353;

int main() {
	int q, k;
	std::cin >> q >> k;

	std::vector<long long> dp(k + 1);
	dp[0] = 1;

	for (int i = 0; i < q; i++) {
		char type;
		int x;
		std::cin >> type >> x;
		if (type == '+') {
			for (int j = k; j >= x; j--) { (dp[j] += dp[j - x]) %= MOD; }
		} else {
			for (int j = x; j <= k; j++) { (dp[j] += MOD - dp[j - x]) %= MOD; }
		}
		std::cout << dp[k] << '\n';
	}
}
```

</CPPSection>
<PySection>

```py
MOD = 998244353

q, k = map(int, input().split())
dp = [0] * (k + 1)

dp[0] = 1

for i in  range(q):
    a = input().strip()
    t, x = a.split()
    x = int(x)
    if t == '+':
        for j in range(k, x - 1, -1):
            dp[j] += dp[j - x]
    else:
        for j in range(x, k + 1):
            dp[j] += MOD - dp[j - x]
    print(dp[k] % MOD)
```

</PySection>
</LanguageSection>
