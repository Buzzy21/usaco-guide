---
id: ac-MexMin
source: AC
title: Mex Min
author: David Zhou
---

## Explanation

We can use a sliding window to keep track of the $M$ elements that cannot be excluded. To track the excluded elements, we can store all integers from $0$ to $N$ in a set and report the lowest value in the set for each window. A frequency table is used to track the number of instances of an element in the window.

## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <climits>
#include <iostream>
#include <set>
#include <unordered_map>
#include <vector>

using namespace std;

int main() {
	int n, m;
	cin >> n >> m;

	set<int> s;
	for (int i = 0; i <= n; i++) { s.insert(i); }
	vector<int> v(n);
	for (int i = 0; i < n; i++) { cin >> v[i]; }

	int res = INT_MAX;
	unordered_map<int, int> window_freq;
	for (int i = 0; i < n; i++) {
		if (i < m) {
			s.erase(v[i]);
			window_freq[v[i]]++;
		} else {
			res = min(res, *s.begin());
			window_freq[v[i]]++;
			s.erase(v[i]);
			window_freq[v[i - m]]--;
			if (window_freq[v[i - m]] == 0) {
				window_freq.erase(v[i - m]);
				s.insert(v[i - m]);
			}
		}
	}

	cout << min(res, *s.begin()) << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());

		int[] v = new int[n];
		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { v[i] = Integer.parseInt(st.nextToken()); }

		TreeSet<Integer> s = new TreeSet<>();
		for (int i = 0; i <= n; i++) { s.add(i); }

		Map<Integer, Integer> windowFreq = new HashMap<>();
		int res = Integer.MAX_VALUE;
		for (int i = 0; i < n; i++) {
			if (i < m) {
				s.remove(v[i]);
				windowFreq.put(v[i], windowFreq.getOrDefault(v[i], 0) + 1);
			} else {
				res = Math.min(res, s.first());
				s.remove(v[i]);
				windowFreq.put(v[i], windowFreq.getOrDefault(v[i], 0) + 1);
				int old = v[i - m];
				windowFreq.put(old, windowFreq.get(old) - 1);
				if (windowFreq.get(old) == 0) {
					windowFreq.remove(old);
					s.add(old);
				}
			}
		}

		System.out.println(Math.min(res, s.first()));
	}
}
```

</JavaSection>

<PySection>

<Warning>

This solution TLEs even with PyPy.

</Warning>

```py
import sys
from collections import defaultdict
from bisect import bisect_left, insort


def main():
	input = sys.stdin.readline
	n, m = map(int, input().split())
	v = list(map(int, input().split()))

	s = list(range(n + 1))
	present = [True] * (n + 1)
	window_freq = defaultdict(int)
	res = float("inf")

	for i in range(n):
		if i < m:
			if present[v[i]]:
				s.pop(bisect_left(s, v[i]))
				present[v[i]] = False
			window_freq[v[i]] += 1
		else:
			res = min(res, s[0])
			if present[v[i]]:
				s.pop(bisect_left(s, v[i]))
				present[v[i]] = False
			window_freq[v[i]] += 1
			old = v[i - m]
			window_freq[old] -= 1
			if window_freq[old] == 0:
				window_freq.pop(old)
				if not present[old]:
					insort(s, old)
					present[old] = True

	print(min(res, s[0]))


if __name__ == "__main__":
	main()
```

</PySection>

</LanguageSection>

## Alternate Solution

We can make an observation that eliminates the need to actually keep track of the window. An element can be excluded from the window for two reasons:
- There is a gap of at least size $M$ between two instances of the same number.
- The element does not appear at all.
Thus, we can keep track of the last seen position of every element and determine if there is ever a gap of size $M$ between the two positions. After, we can compare each last seen position with the endpoint both to check for distance from the end and also existence.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
	int n, m;
	cin >> n >> m;

	vector<int> v(n);
	for (int i = 0; i < n; i++) { cin >> v[i]; }

	vector<int> last_seen_pos(n + 1, -1);
	vector<bool> valid(n + 1);

	for (int i = 0; i < n; i++) {
		if (i - last_seen_pos[v[i]] > m) { valid[v[i]] = true; }
		last_seen_pos[v[i]] = i;
	}

	// compare endpoint with last_seen_pos
	// this check also ensures that elements that do not appear are considered valid
	for (int i = 0; i <= n; i++) {
		if (n - last_seen_pos[i] > m) { valid[i] = true; }
	}

	for (int i = 0; i <= n; i++) {
		if (valid[i]) {
			cout << i << endl;
			break;
		}
	}
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Alt {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] nm = br.readLine().split(" ");
		int n = Integer.parseInt(nm[0]);
		int m = Integer.parseInt(nm[1]);

		int[] nums = new int[n];
		String[] vals = br.readLine().split(" ");
		for (int i = 0; i < n; i++) { nums[i] = Integer.parseInt(vals[i]); }

		int[] lastSeenPos = new int[n + 1];
		Arrays.fill(lastSeenPos, -1);
		boolean[] valid = new boolean[n + 1];

		for (int i = 0; i < n; i++) {
			if (i - lastSeenPos[nums[i]] > m) { valid[nums[i]] = true; }
			lastSeenPos[nums[i]] = i;
		}

		for (int i = 0; i <= n; i++) {
			if (n - lastSeenPos[i] > m) { valid[i] = true; }
		}

		for (int i = 0; i <= n; i++) {
			if (valid[i]) {
				System.out.println(i);
				break;
			}
		}

		br.close();
	}
}
```

</JavaSection>

<PySection>

```py
import sys

input = sys.stdin.readline


def main():
	n, m = map(int, input().split())
	v = list(map(int, input().split()))

	last_seen_pos = [-1] * (n + 1)
	valid = [False] * (n + 1)

	for i in range(n):
		if i - last_seen_pos[v[i]] > m:
			valid[v[i]] = True
		last_seen_pos[v[i]] = i

	for i in range(n + 1):
		if n - last_seen_pos[i] > m:
			valid[i] = True

	for i in range(n + 1):
		if valid[i]:
			print(i)
			break


if __name__ == "__main__":
	main()
```

</PySection>

</LanguageSection>
