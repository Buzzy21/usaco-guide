---
id: cf-687D
source: CF
title: The Values You Can Make
author: Rameez Parwez
---

[Official Analysis (C++)](https://codeforces.com/blog/entry/45770)

## Explanation

Let $\texttt{dp[i][j]}$ represents whether it is possible to select a group of coins such that a subset of them sums to $i$ and the rest of them in the group sums to $j$. This way we will have coins whose sum is $i + j$, and we are interested in cases where we have $i + j = k$.

Our base case will be $\texttt{dp[0][0] = 1}$ representing empty selection. Now for each coin, we will update our $dp$ array by considering two possibilities

- include the coin in Arya's part
- include the coin in the rest of the selection

Finally we will collect all the values $x$ such that $\texttt{dp[x][k - x]}$ is true which are eventually the values Arya can form.

## Implementation

**Time Complexity:** $\mathcal{O}(NK^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <vector>

int main() {
	int n, k;
	std::cin >> n >> k;
	std::vector<int> coins(n);
	for (int &x : coins) { std::cin >> x; }

	std::vector dp(k + 1, std::vector<int>(k + 1));
	dp[0][0] = 1;
	for (int a : coins) {
		std::vector<std::vector<int>> new_dp(dp);
		for (int i = 0; i <= k; i++) {
			for (int j = 0; j <= k - i; j++) {

				/*
				 * If we can reach (i - a, j), then we can reach
				 * (i, j) by adding a to arya's subset.
				 */
				if (i >= a) { new_dp[i][j] |= dp[i - a][j]; }

				/*
				 * If we can reach (i, j - a), then we can reach
				 * (i, j) by adding a to the rest.
				 */
				if (j >= a) { new_dp[i][j] |= dp[i][j - a]; }
			}
		}
		std::move(begin(new_dp), end(new_dp), begin(dp));
	}

	std::vector<int> res;
	for (int i = 0; i <= k; i++) {
		if (dp[i][k - i]) { res.push_back(i); }
	}

	std::cout << res.size() << '\n';
	for (int i = 0; i < res.size(); i++) {
		std::cout << res[i] << " \n"[i == res.size() - 1];
	}
}
```

</CPPSection>
<PySection>

```py
n, k = map(int, input().split())
coins = list(map(int, input().split()))

dp = [[0] * (k + 1) for _ in range(k + 1)]
dp[0][0] = 1

for a in coins:
	new_dp = [x[:] for x in dp]
	for i in range(k + 1):
		for j in range(k - i + 1):
		    
			# If we can reach (i - a, j), then we can reach
		    # (i, j) by adding a to arya's subset.
			if i >= a:
				new_dp[i][j] |= dp[i - a][j]

			# If we can reach (i, j - a), then we can reach
			# (i, j) by adding a to the rest.
			if j >= a:
				new_dp[i][j] |= dp[i][j - a]
	dp = new_dp

res = [i for i in range(k + 1) if dp[i][k - i]]

print(len(res))
print(*res)
```

</PySection>
</LanguageSection>
