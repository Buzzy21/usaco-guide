---
id: usaco-715
source: USACO Silver 2017 February
title: Why Did the Cow Cross the Road II
author: Albert Zhu, Juheon Rhee, Sachet Abeysinghe
---
[Official Analysis (C++)](http://www.usaco.org/current/data/sol_maxcross_silver_feb17.html)

## Explanation

We can represent this problem as an array $a$ of $N$ signals, such that the $i$th signal is $0$ if it is working and $1$ if it is not working. Then, we have reduced the problem to finding the subarray of length $K$ with the least number of $1$s (i.e., the least sum).

To do this, compute the prefix sum array $p$ such that $p_0 = 0$ and $p_i = a_1 + a_2 + ... + a_{i-1}$. Then, for each $i$ from $0$ to $N - K$, you can find the number of $1$s (broken signals) with the formula $p_{i + K} - p_i$, and take the minimum across all values.

You can also solve this using a sliding window of length $K$, keeping track of the sum across all windows.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

void setIO(string prob) {
	freopen((prob + ".in").c_str(), "r", stdin);
	freopen((prob + ".out").c_str(), "w", stdout);
}

const int MAX_N = 1e5;

int sigs[MAX_N];
int presum[MAX_N];

int main() {
	setIO("maxcross");
	int n, k, b;
	cin >> n >> k >> b;

	// input broken signals
	for (int i = 0; i < b; i++) {
		int x;
		cin >> x;
		sigs[x]++;
	}

	// prefix sums precomputation
	for (int i = 0; i < n; i++) { presum[i + 1] = sigs[i + 1] + presum[i]; }

	int ret = INT_MAX;
	// find the answer
	for (int i = 0; i <= n - k; i++) { ret = min(ret, presum[i + k] - presum[i]); }
	cout << ret << '\n';
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class MaxCross {
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new FileReader("maxcross.in"));
		PrintWriter pw = new PrintWriter("maxcross.out");
		StringTokenizer st = new StringTokenizer(in.readLine());

		int n = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());
		int b = Integer.parseInt(st.nextToken());

		int[] sigs = new int[n + 1];
		int[] presum = new int[n + 1];

		// input broken signals
		for (int i = 0; i < b; i++) { sigs[Integer.parseInt(in.readLine())]++; }

		// prefix sums precomputation
		for (int i = 0; i < n; i++) { presum[i + 1] = sigs[i + 1] + presum[i]; }

		int ret = n + 1;
		// find the answer
		for (int i = 0; i <= n - k; i++) {
			ret = Math.min(ret, presum[i + k] - presum[i]);
		}
		pw.println(ret);
		pw.close();
	}
}
```

</JavaSection>

<PySection>

```py
with open("maxcross.in") as read:
	n, k, b = map(int, read.readline().split())
	seen = [0] * (n + 1)
	left, right = 1, k
	value = 0

	for _ in range(b):
		seen[int(read.readline())] = 1

for i in range(left, right + 1):
	value += seen[i]

possible = [value]
while n > right:
	value += seen[right + 1] - seen[left]
	left, right = left + 1, right + 1
	possible.append(value)

print(min(possible), file=open("maxcross.out", "w"))
```

</PySection>
</LanguageSection>
